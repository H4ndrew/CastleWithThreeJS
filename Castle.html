<!DOCTYPE html>
<html lang="en">

<head>
	<title>Castle</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../three.js/examples/main.css">
</head>

<body>

	<body>

		<style>
			html,
			body {
				height: 100%;
				margin: 0;
			}


			#overlay {
				position: absolute;
				z-index: 2;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
				background: rgba(0, 0, 0, 0.7);
			}

			#overlay button {
				background: #ffffff;
				border: 0;
				color: #000000;
				padding: 16px 20px;
				text-transform: uppercase;
				cursor: pointer;
			}

			#info {
				position: absolute;
				top: 0px;
				width: 100%;
				padding: 10px;
				box-sizing: border-box;
				text-align: center;
				-moz-user-select: none;
				-webkit-user-select: none;
				-ms-user-select: none;
				user-select: none;
				pointer-events: none;
				z-index: 1;
				/* TODO Solve this in HTML */
				color: #9effff;
			}
		</style>


		<script>
			function remove(elem) {
				elem.parentNode.removeChild(elem);
			}
		</script>

		<div id="overlay" , onclick="remove(this)">
			<button id="startButton">click></button>
		</div>

		<div id="info">
			1PLIKÃ‰140
		</div>


		<script type="module">

			import * as THREE from '../three.js/build/three.module.js';
			import { FirstPersonControls } from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/controls/FirstPersonControls.js';
			import { OrbitControls } from '../three.js/examples/jsm/controls/OrbitControls.js';
			import { CameraControls } from '../three.js/examples/jsm/controls/experimental/CameraControls.js';
			import { GUI } from '../three.js/examples/jsm/libs/dat.gui.module.js';
			import { Sky } from "../three.js/examples/jsm/objects/Sky.js"
			import { FBXLoader } from '../three.js/examples/jsm/loaders/FBXLoader.js';
			import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/GLTFLoader.js';
			import Stats from '../three.js/examples/jsm/libs/stats.module.js';
			import { DragControls } from '../three.js/examples/jsm/controls/DragControls';
			import * as CANNON from './node_modules/cannon-es/dist/cannon-es.js';



			let camera, scene, renderer;
			let plane, road, door, gate, castleWindow, court;
			let pointer, spotLight;
			let cubeGeo, cubeMaterial;
			let gui, sun, fbx1;
			var startColor;

			const TextureLoader = new THREE.TextureLoader();

			const grass = TextureLoader.load('textures/grass.jpg');
			const brick = TextureLoader.load('../three.js/examples/textures/brick_bump.jpg');
			const redbrick = TextureLoader.load('textures/Roof_Tiles_Terracotta_006_basecolor.jpg');
			const sky = TextureLoader.load('textures/sky.jpg');
			const paving = TextureLoader.load('textures/floor.jpg');
			const woodenDoor = TextureLoader.load('textures/door.png');
			const guardGateTexture = TextureLoader.load('textures/gate.png');
			const windowTexture = TextureLoader.load('textures/window.png');
			const courtTexture = TextureLoader.load('textures/stone.png');
			const woodenBox = TextureLoader.load('textures/woodenBox.jpg');

			const wBox = new THREE.MeshPhongMaterial({ map: woodenBox });
			const tiles = new THREE.MeshPhongMaterial({ map: redbrick });
			const material = new THREE.MeshPhongMaterial({ map: brick });
			const guardGate = new THREE.MeshPhongMaterial({ map: guardGateTexture, transparent: true });

			const stats = Stats()
			document.body.appendChild(stats.dom)

			const world = new CANNON.World()
			world.gravity.set(0, -9.82, 0)

			const timeStep = 1 / 60;

			const planes = [];
			const objects = [];
			const objectBodies = [];

			let x, y, z;

			init();
			render();
			buildGui();

			function init() {
				camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
				camera.position.set(500, 800, 1300);
				camera.lookAt(0, 0, 0);

				scene = new THREE.Scene();
				scene.background = sky;

				//south wall
				x = -500;
				y = 25;
				z = 525;
				createWall(x, y, z, "south", 21, 3);

				//north wall
				x = -500;
				y = 25;
				z = -575;
				createWall(x, y, z, "north", 21, 3);

				//west wall
				x = -475;
				y = 25;
				z = -525;
				createWall(x, y, z, "west", 21, 3);

				//east wall
				x = 525;
				y = 25;
				z = -525;
				createWall(x, y, z, "east", 21, 3);

				//south west tower
				x = -400;
				y = 50 * 5 / 2;
				z = 450;
				createTower(x, y, z);

				//south east tower
				x = 450;
				y = 50 * 5 / 2;
				z = 450;
				createTower(x, y, z);

				//north east tower
				x = 450;
				y = 50 * 5 / 2;
				z = -500;
				createTower(x, y, z);

				//north west tower
				x = -400;
				y = 50 * 5 / 2;
				z = -500;
				createTower(x, y, z);

				//central piece
				x = -250;
				y = 25;
				z = -250;
				createWall(x, y, z, "north", 11, 6);

				x = -250;
				y = 25;
				z = 250;
				createWall(x, y, z, "south", 3, 6);
				x = 150;
				y = 25;
				z = 250;
				createWall(x, y, z, "south", 3, 6);

				x = -275;
				y = 25;
				z = -250;
				createWall(x, y, z, "west", 11, 6);

				x = 325;
				y = 25;
				z = -250;
				createWall(x, y, z, "east", 11, 6);

				//central tower
				x = -125;
				y = 25;
				z = -150;
				createWall(x, y, z, "north", 6, 11, "no");

				x = 180;
				y = 25;
				z = -125;
				createWall(x, y, z, "east", 6, 11, "no");

				x = -125;
				y = 25;
				z = -125;
				createWall(x, y, z, "west", 6, 11, "no");

				x = -125;
				y = 25;
				z = 150;
				createWall(x, y, z, "south", 6, 11, "no");

				//central pyramidal roof
				x = 25;
				y = 625;
				z = 0;
				const pyramidRoofGeo = new THREE.CylinderGeometry(1, 50 * 6, 50 * 4, 4);
				const pyramidRoof = new THREE.Mesh(pyramidRoofGeo, tiles);
				pyramidRoof.rotateY(-Math.PI / 4);
				pyramidRoof.position.set(25, 625, 0);
				scene.add(pyramidRoof);

				const grassGeo = new THREE.BoxGeometry(300, 300, 2);
				grassGeo.rotateX(-Math.PI / 2);
				x = -600;
				y = 0;
				z = -600;

				// const gridHelper = new THREE.GridHelper(1500, 25);
				// gridHelper.position.set(0, 0, 0);
				// scene.add(gridHelper);

				for (var i = 0; i < 5; i++) {
					for (var j = 0; j < 5; j++) {
						plane = new THREE.Mesh(grassGeo, new THREE.MeshPhongMaterial({ map: grass }));
						plane.castShadow = true;
						plane.receiveShadow = true;
						plane.position.set(x, y, z);
						if (j % 2 == 0) {
							plane.rotateY(Math.PI / 2);
						}
						if (i % 2 != 0) {
							plane.rotateY(Math.PI / 2);
						}
						if (i % 2 != 0 && j % 2 != 0) {
							plane.rotateY(Math.PI);
						}

						scene.add(plane);
						const planeShape = new CANNON.Plane()
						const planeBody = new CANNON.Body({ mass: 0 })
						planeBody.addShape(planeShape)
						planeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2)
						world.addBody(planeBody)
						x = x + 300;
					}

					x = -600;
					z = z + 300;
				}
				planes.push(plane);

				const roadGeo = new THREE.PlaneGeometry(250, 300);
				roadGeo.rotateX(-Math.PI / 2);
				x = 25;
				y = 2;
				z = 600;

				for (var i = 0; i < 2; i++) {
					road = new THREE.Mesh(roadGeo, new THREE.MeshPhongMaterial({ map: paving, receiveShadow: true }));
					road.position.set(x, y, z);
					scene.add(road);
					z = z - 300;
				}

				const doorGeo = new THREE.PlaneGeometry(200, 200);
				x = 25;
				y = 85;
				z = 176;
				door = new THREE.Mesh(doorGeo, new THREE.MeshPhongMaterial({ map: woodenDoor, transparent: true }));
				door.position.set(x, y, z);
				scene.add(door);

				createWindow(x, y + 300, z, 200, 200, "south");
				createWindow(x, y + 300, z - 352, 200, 200, "north");
				createWindow(x + 181, y + 300, z - 172, 200, 200, "east");
				createWindow(x - 176, y + 300, z - 172, 200, 200, "west");

				//lights
				const ambientLight = new THREE.AmbientLight(0x606060, 0.1);
				scene.add(ambientLight);

				spotLight = new THREE.SpotLight(0xffffff, 0.5);
				spotLight.position.set(-1000, 1500, 1000);
				spotLight.distance = 5000;
				spotLight.angle = Math.PI / 5;
				spotLight.castShadow = true;
				spotLight.shadow.mapSize.width = 512;
				spotLight.shadow.mapSize.height = 512;
				spotLight.shadow.camera.near = 100;
				spotLight.shadow.camera.far = 2000;
				spotLight.shadow.focus = 1;
				scene.add(spotLight);

				// var lightHelper = new THREE.SpotLightHelper(spotLight, 5);
				// scene.add(lightHelper);

				// var shadowCameraHelper = new THREE.CameraHelper(spotLight.shadow.camera);
				// scene.add(shadowCameraHelper);


				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.outputEncoding = THREE.sRGBEncoding;

				document.body.appendChild(renderer.domElement);
				document.addEventListener('pointermove', onPointerMove);

				window.addEventListener('resize', onWindowResize);

				const geometry = new THREE.SphereGeometry(40);

				for (var i = 0; i < 100; i++) {
					var object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));

					object.position.x = Math.random() * 1000 - 500;
					object.position.y = Math.random() * 600;
					object.position.z = Math.random() * 800 - 400;

					console.log(object.position.x)

					object.castShadow = true;
					object.receiveShadow = true;

					scene.add(object);

					var objectShape = new CANNON.Sphere(1)
					var objectBody = new CANNON.Body({ mass: 1 })
					objectBodies.push(objectBody);
					objectBody.addShape(objectShape)

					objectBody.position.x = object.position.x
					objectBody.position.y = object.position.y
					objectBody.position.z = object.position.z

					console.log(objectBody.position.x)

					world.addBody(objectBody)

					objects.push(object);
				}

				render();
				animate();
			}
			var control = new DragControls(objects, camera, renderer.domElement);
			control.addEventListener('dragstart', dragStartCallback);
			control.addEventListener('dragend', dragendCallback);

			function dragStartCallback(event) {
				startColor = event.object.material.color.getHex();
				event.object.material.color.setHex(0x000000);
				controls.enabled = false;
			}
			function dragendCallback(event) {
				event.object.material.color.setHex(startColor);
				controls.enabled = true;
			}
			function animate() {
				world.step(timeStep);
				for (var i = 0; i < 100; i++) {
					objects[i].position.set(
						objectBodies[i].position.x,
						objectBodies[i].position.y,
						objectBodies[i].position.z
					)
					objects[i].quaternion.set(
						objectBodies[i].quaternion.x,
						objectBodies[i].quaternion.y,
						objectBodies[i].quaternion.z,
						objectBodies[i].quaternion.w
					)
				}

				requestAnimationFrame(animate);
				renderer.render(scene, camera);
			};


			function buildGui() {

				gui = new GUI();

				const params = {
					'light color': spotLight.color.getHex(),
					intensity: spotLight.intensity
				};

				gui.addColor(params, 'light color').onChange(function (val) {
					spotLight.color.setHex(val);
					render();
				});

				gui.add(spotLight.position, "x", "y", "z", 10);

				gui.add(params, 'intensity', 0, 2).onChange(function (val) {
					spotLight.intensity = val;
					render();
				});
				const physicsFolder = gui.addFolder('Physics')
				physicsFolder.add(world.gravity, 'x', -10.0, 10.0, 0.1)
				physicsFolder.add(world.gravity, 'y', -10.0, 10.0, 0.1)
				physicsFolder.add(world.gravity, 'z', -10.0, 10.0, 0.1)
				physicsFolder.open()
				gui.open();

			}


			function createWindow(x, y, z, height, width, direction) {
				const windowGeo = new THREE.PlaneGeometry(height, width);
				castleWindow = new THREE.Mesh(windowGeo, new THREE.MeshPhongMaterial({ map: windowTexture, transparent: true }));
				console.log(direction);
				switch (direction) {
					case 'south':
						castleWindow.position.set(x, y, z);
						scene.add(castleWindow);
						break;

					case 'north':
						castleWindow.position.set(x, y, z);
						castleWindow.rotateY(-Math.PI);
						scene.add(castleWindow);
						break;

					case 'east':
						castleWindow.position.set(x, y, z);
						castleWindow.rotateY(Math.PI / 2);
						scene.add(castleWindow);
						break;

					case 'west':
						castleWindow.position.set(x, y, z);
						castleWindow.rotateY(-Math.PI / 2);
						scene.add(castleWindow);
						break;

					default:
						console.log("wrond window direction value");
				}

			}

			function createWall(x, y, z, side, length, height, noIndent) {
				console.log(noIndent);
				let indent;
				let xstart = x;
				let zstart = z;
				switch (side) {
					case 'north':
						for (var i = 0; i < height; i++) {
							for (var j = 0; j < length; j++) {
								const wall = new THREE.BoxGeometry(50, 50, 50);
								const cube = new THREE.Mesh(wall, material);
								cube.castShadow = true;
								cube.receiveShadow = true;
								cube.position.set(x + 25, y, z);
								x = x + 50;
								scene.add(cube);
							}
							x = xstart;
							y = y + 50;
						}
						if (noIndent === undefined) {
							indent = 1;
							for (var j = 0; j < length; j++) {
								if (indent % 2 != 0) {
									const wall = new THREE.BoxGeometry(50, 50, 50);
									const cube = new THREE.Mesh(wall, material);
									cube.castShadow = true;
									cube.receiveShadow = true;
									cube.position.set(x + 25, y, z);
									x = x + 50;
									scene.add(cube);
									indent += 1;
								} else {
									indent += 1;
									x = x + 50
									continue;
								}
							}
						} else {
							console.log("no indent");
						}
						break;

					case 'west':
						for (var i = 0; i < height; i++) {
							for (var j = 0; j < length; j++) {
								const wall = new THREE.BoxGeometry(50, 50, 50);
								const cube = new THREE.Mesh(wall, material);
								cube.castShadow = true;
								cube.receiveShadow = true;
								cube.position.set(x, y, z);
								z = z + 50;
								scene.add(cube);
							}
							z = zstart;
							y = y + 50;
						}
						if (noIndent === undefined) {
							indent = 1;
							for (var j = 0; j < length; j++) {
								if (indent % 2 == 0) {
									const wall = new THREE.BoxGeometry(50, 50, 50);
									const cube = new THREE.Mesh(wall, material);
									cube.castShadow = true;
									cube.receiveShadow = true;
									cube.position.set(x, y, z);
									z = z + 50;
									scene.add(cube);
									indent += 1;
								} else {
									indent += 1;
									z = z + 50
									continue;
								}
							}
						} else {
							console.log("no indent");
						}
						break;

					case 'east':
						for (var i = 0; i < height; i++) {
							for (var j = 0; j < length; j++) {
								const wall = new THREE.BoxGeometry(50, 50, 50);
								const cube = new THREE.Mesh(wall, material);
								cube.castShadow = true;
								cube.receiveShadow = true;
								cube.position.set(x, y, z)
								z = z + 50
								scene.add(cube);
							}
							z = zstart
							y = y + 50
						}
						if (noIndent === undefined) {
							indent = 0;
							for (var j = 0; j < length; j++) {
								if (indent % 2 != 0) {
									const wall = new THREE.BoxGeometry(50, 50, 50);
									const cube = new THREE.Mesh(wall, material);
									cube.castShadow = true;
									cube.receiveShadow = true;
									cube.position.set(x, y, z);
									z = z + 50;
									scene.add(cube);
									indent += 1;
								} else {
									indent += 1;
									z = z + 50
									continue;
								}
							}
						} else {
							console.log("no indent");
						}
						break;

					case 'south':
						for (var i = 0; i < height; i++) {
							for (var j = 0; j < length; j++) {
								const wall = new THREE.BoxGeometry(50, 50, 50);
								if (j > 6 && j < 14) {
									if (j == 7 || j == 13) {
										const cube = new THREE.Mesh(wall, material);
										cube.castShadow = true;
										cube.receiveShadow = true;
										cube.position.set(x + 25, y, z)
										scene.add(cube);
									}
								} else {
									const cube = new THREE.Mesh(wall, material);
									cube.castShadow = true;
									cube.receiveShadow = true;
									cube.position.set(x + 25, y, z)
									scene.add(cube);
								}
								x = x + 50;
							}
							x = xstart;
							y = y + 50;
						}
						if (noIndent === undefined) {
							indent = 1;
							for (var j = 0; j < length; j++) {
								if (indent % 2 != 0) {
									if (j != 8 && j != 10 && j != 12) {
										const wall = new THREE.BoxGeometry(50, 50, 50);
										const cube = new THREE.Mesh(wall, material);
										cube.castShadow = true;
										cube.receiveShadow = true;
										cube.position.set(x + 25, y, z);
										x = x + 50;
										scene.add(cube);
										indent += 1;
									} else {
										x = x + 50;
										indent += 1;
									}
								} else {
									indent += 1;
									x = x + 50
									continue;
								}
							}
						} else {
							console.log("no indent");
						}
						break;

					default:
						console.log("side not recognized")
				}
			}

			function createTower(x, y, z) {
				const tower = new THREE.CylinderGeometry(50, 50, 50 * 5, 320);
				const cylinder = new THREE.Mesh(tower, material);
				cylinder.castShadow = true;
				cylinder.position.set(x, y, z);
				scene.add(cylinder);
				y = y + 225
				const cone = new THREE.ConeGeometry(80, 200, 320);
				const roof = new THREE.Mesh(cone, tiles);
				roof.position.set(x, y, z);
				scene.add(roof);
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);

				render();

			}


			class BasicCharacterControls {
				constructor(params) {
					this._Init(params);// this. fait rÃ©fÃ©rence Ã  l'object courant (la variable this a comme valeur lâ€™objet qui est en train dâ€™Ãªtre construit.)
				}

				_Init(params) {
					this.params = params;//ici on dÃ©fini les paramÃ¨tres Ã  prendre en compte pour le mouvement 
					this.move = {
						forward: false,
						backward: false,
						left: false,
						right: false,
					};
					this.decceleration = new THREE.Vector3(-0.0005, -0.0001, -5.0); //THREE. est un point dans l'espace 3D
					this.acceleration = new THREE.Vector3(5, 2, 100);
					this.velocity = new THREE.Vector3(0, 0, 0);

					document.addEventListener('keydown', (e) => this.onKeyDown(e), false);
					document.addEventListener('keyup', (e) => this.onKeyUp(e), false);
				}

				onKeyDown(event) {
					switch (event.keyCode) {//ici on controle les mouvement de notre object 3D prÃ©dÃ©fini Ã  l'avance en  grace au switch case 
						case 87: // w
							this.move.forward = true;
							break;
						case 65: // a
							this.move.left = true;
							break;
						case 83: // s
							this.move.backward = true;
							break;
						case 68: // d
							this.move.right = true;
							break;
						case 38: // up
						case 37: // left
						case 40: // down
						case 39: // right
							break;
					}
				}

				onKeyUp(event) {
					switch (event.keyCode) {//lorqu'on enlÃ¨ve le doigt sur la touche il arret d'executer 
						case 87: // w
							this.move.forward = false;
							break;
						case 65: // a
							this.move.left = false;
							break;
						case 83: // s
							this.move.backward = false;
							break;
						case 68: // d
							this.move.right = false;
							break;
						case 38: // up
						case 37: // left
						case 40: // down
						case 39: // right
							break;
					}
				}

				Update(timeInSeconds) {
					const velocity = this.velocity;
					const frameDecceleration = new THREE.Vector3(
						velocity.x * this.decceleration.x,
						velocity.y * this.decceleration.y,
						velocity.z * this.decceleration.z
					);// pour obtenir la frameDecceleration on multiplie la velocitÃ© par la dÃ©ccÃ©lÃ©ration 
					frameDecceleration.multiplyScalar(timeInSeconds);//mutiplyscalar multiplie le vecteur par le scalaire (timeInSeconds)
					frameDecceleration.z = Math.sign(frameDecceleration.z) * Math.min(
						Math.abs(frameDecceleration.z), Math.abs(velocity.z));//Math.sign permet de savoir le signe ; Math.abs retourne la valeur absolue;

					velocity.add(frameDecceleration);

					const controlObject = this.params.target;
					const Q = new THREE.Quaternion();
					const A = new THREE.Vector3();
					const R = controlObject.quaternion.clone();

					if (this.move.forward) {//mouvement en avant 
						velocity.z += this.acceleration.z * timeInSeconds;
					}
					if (this.move.backward) {//mouvement en arriÃ¨re
						velocity.z -= this.acceleration.z * timeInSeconds;
					}
					if (this.move.left) {//permet de se tourner vers la gauche
						A.set(0, 1, 0);
						Q.setFromAxisAngle(A, Math.PI * timeInSeconds * this.acceleration.y);
						R.multiply(Q);
					}
					if (this.move.right) {//permet de se tourner vers la droite
						A.set(0, 1, 0);
						Q.setFromAxisAngle(A, -Math.PI * timeInSeconds * this.acceleration.y);
						R.multiply(Q);
					}

					controlObject.quaternion.copy(R);//quaternion est utilisÃ© pour reprÃ©senter les rotation

					const oldPosition = new THREE.Vector3();
					oldPosition.copy(controlObject.position);

					const forward = new THREE.Vector3(0, 0, 1);
					forward.applyQuaternion(controlObject.quaternion);
					forward.normalize();

					const sideways = new THREE.Vector3(1, 0, 0);
					sideways.applyQuaternion(controlObject.quaternion);
					sideways.normalize();

					sideways.multiplyScalar(velocity.x * timeInSeconds);
					forward.multiplyScalar(velocity.z * timeInSeconds);

					controlObject.position.add(forward);
					controlObject.position.add(sideways);

					oldPosition.copy(controlObject.position);
				}
			}


			class LoadModelDemo {
				constructor() {
					this.Initialize();
				}

				Initialize() {
					this.mixers = [];
					this.previousRAF = null;

					/*this.Model();*/
					this.LoadAnimatedModel();
					this.RAF();
				}

				LoadAnimatedModel() {
					const loader = new FBXLoader();//permet le bon fonctionnemennt du model (type du model 3D)
					loader.setPath('resources/ac/');
					loader.load('spider man homecoming.fbx', (fbx) => {
						fbx.scale.setScalar(0.9);
						fbx.traverse(c => {
							c.castShadow = true;
						});

						const params = {
							target: fbx,
							camera: this._camera,
						}
						this._controls = new BasicCharacterControls(params);

						const anim = new FBXLoader();
						anim.setPath('resources/ac/');
						anim.load('Walk In Circle.fbx', (anim) => {
							const m = new THREE.AnimationMixer(fbx);
							this.mixers.push(m);
							const idle = m.clipAction(anim.animations[0]);
							idle.play();
						});
						scene.add(fbx);
						fbx.position.set(-50, 10, 500);
					});
				}

				RAF() {
					requestAnimationFrame((t) => {
						if (this.previousRAF === null) {
							this.previousRAF = t;
						}

						this.RAF();

						//this._threejs.render(this.scene, this.camera);
						this.Step(t - this.previousRAF);
						this.previousRAF = t;
					});
				}

				Step(timeElapsed) {
					const timeElapsedS = timeElapsed * 0.001;
					if (this.mixers) {
						this.mixers.map(m => m.update(timeElapsedS));
					}

					if (this.controls) {
						this.controls.Update(timeElapsedS);
					}
				}
			}

			let APP = null;

			window.addEventListener('DOMContentLoaded', () => {
				APP = new LoadModelDemo();//LoadModel est chargÃ© aprÃ¨s que le chateau soit bien telechargÃ©
			});




			function onPointerMove(event) {
				//pointer.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
				//raycaster.setFromCamera(pointer, camera);
				render();
			}

			function render() {
				renderer.render(scene, camera);
				stats.update();
				//fbx1.position.z += 0.1;

			}


			const controls = new OrbitControls(camera, renderer.domElement);
			controls.target.set(0, 12, 0);

			controls.update();


			// create an AudioListener and add it to the camera
			const listener = new THREE.AudioListener();
			camera.add(listener);

			// create the PositionalAudio object (passing in the listener)
			const sound = new THREE.PositionalAudio(listener);

			// load a sound and set it as the PositionalAudio object's buffer
			const audioLoader = new THREE.AudioLoader();
			audioLoader.load('./audio/GÃ©nÃ©rique Merlin.ogg', function (buffer) {
				sound.setBuffer(buffer);
				sound.setRefDistance(20);
				sound.play();
			});

			// create an object for the sound to play from


			const mesh = new THREE.Mesh(tower, guardGate);
			scene.add(mesh);

			// finally add the sound to the mesh
			mesh.add(sound);




			class BasicCharacterControllerProxy {
				constructor(animations) {
					this._animations = animations;
				}

				get animations() {
					return this._animations;
				}
			};


			class BasicCharacterController {
				constructor(params) {
					this._Init(params);
				}

				_Init(params) {

					this._params = params;
					this._decceleration = new THREE.Vector3(-0.0005, -0.0001, -5.0);
					this._acceleration = new THREE.Vector3(1, 0.25, 50.0);
					this._velocity = new THREE.Vector3(0, 0, 0);
					this._position = new THREE.Vector3();

					this._animations = {};
					this._input = new BasicCharacterControllerInput();
					this._stateMachine = new CharacterFSM(
						new BasicCharacterControllerProxy(this._animations));

					this._LoadModels();
				}

				_LoadModels() {
					const loader = new FBXLoader();
					loader.setPath('../ProjetFinal/resources/spiderman/');
					loader.load('mremireh_o_desbiens.fbx', (fbx) => {
						fbx.scale.setScalar(0.1);
						fbx.traverse(c => {
							c.castShadow = true;
						});

						this._target = fbx;
						this._params.scene.add(this._target);

						this._mixer = new THREE.AnimationMixer(this._target);

						this._manager = new THREE.LoadingManager();
						this._manager.onLoad = () => {
							this._stateMachine.SetState('idle');
						};

						const _OnLoad = (animName, anim) => {
							const clip = anim.animations[0];
							const action = this._mixer.clipAction(clip);

							this._animations[animName] = {
								clip: clip,
								action: action,
							};
						};

						const loader = new FBXLoader(this._manager);
						loader.setPath('../ProjetFinal/resources/spiderman/');
						loader.load('walk.fbx', (a) => { _OnLoad('walk', a); });
						loader.load('run.fbx', (a) => { _OnLoad('run', a); });
						loader.load('idle.fbx', (a) => { _OnLoad('idle', a); });
						loader.load('dance.fbx', (a) => { _OnLoad('dance', a); });
					});
				}

				get Position() {
					return this._position;
				}

				get Rotation() {
					if (!this._target) {
						return new THREE.Quaternion();
					}
					return this._target.quaternion;
				}

				Update(timeInSeconds) {
					if (!this._stateMachine._currentState) {
						return;
					}

					this._stateMachine.Update(timeInSeconds, this._input);

					const velocity = this._velocity;
					const frameDecceleration = new THREE.Vector3(
						velocity.x * this._decceleration.x,
						velocity.y * this._decceleration.y,
						velocity.z * this._decceleration.z
					);
					frameDecceleration.multiplyScalar(timeInSeconds);
					frameDecceleration.z = Math.sign(frameDecceleration.z) * Math.min(
						Math.abs(frameDecceleration.z), Math.abs(velocity.z));

					velocity.add(frameDecceleration);

					const controlObject = this._target;
					const _Q = new THREE.Quaternion();
					const _A = new THREE.Vector3();
					const _R = controlObject.quaternion.clone();

					const acc = this._acceleration.clone();
					if (this._input._keys.shift) {
						acc.multiplyScalar(2.0);
					}

					if (this._stateMachine._currentState.Name == 'dance') {
						acc.multiplyScalar(0.0);
					}

					if (this._input._keys.forward) {
						velocity.z += acc.z * timeInSeconds;
					}
					if (this._input._keys.backward) {
						velocity.z -= acc.z * timeInSeconds;
					}
					if (this._input._keys.left) {
						_A.set(0, 1, 0);
						_Q.setFromAxisAngle(_A, 4.0 * Math.PI * timeInSeconds * this._acceleration.y);
						_R.multiply(_Q);
					}
					if (this._input._keys.right) {
						_A.set(0, 1, 0);
						_Q.setFromAxisAngle(_A, 4.0 * -Math.PI * timeInSeconds * this._acceleration.y);
						_R.multiply(_Q);
					}

					controlObject.quaternion.copy(_R);

					const oldPosition = new THREE.Vector3();
					oldPosition.copy(controlObject.position);

					const forward = new THREE.Vector3(0, 0, 1);
					forward.applyQuaternion(controlObject.quaternion);
					forward.normalize();

					const sideways = new THREE.Vector3(1, 0, 0);
					sideways.applyQuaternion(controlObject.quaternion);
					sideways.normalize();

					sideways.multiplyScalar(velocity.x * timeInSeconds);
					forward.multiplyScalar(velocity.z * timeInSeconds);

					controlObject.position.add(forward);
					controlObject.position.add(sideways);

					this._position.copy(controlObject.position);

					if (this._mixer) {
						this._mixer.update(timeInSeconds);
					}
				}
			};

			class BasicCharacterControllerInput {
				constructor() {
					this._Init();
				}

				_Init() {
					this._keys = {
						forward: false,
						backward: false,
						left: false,
						right: false,
						space: false,
						shift: false,
					};
					document.addEventListener('keydown', (e) => this._onKeyDown(e), false);
					document.addEventListener('keyup', (e) => this._onKeyUp(e), false);
				}

				_onKeyDown(event) {
					switch (event.keyCode) {
						case 87: // w
							this._keys.forward = true;
							break;
						case 65: // a
							this._keys.left = true;
							break;
						case 83: // s
							this._keys.backward = true;
							break;
						case 68: // d
							this._keys.right = true;
							break;
						case 32: // SPACE
							this._keys.space = true;
							break;
						case 16: // SHIFT
							this._keys.shift = true;
							break;
					}
				}

				_onKeyUp(event) {
					switch (event.keyCode) {
						case 87: // w
							this._keys.forward = false;
							break;
						case 65: // a
							this._keys.left = false;
							break;
						case 83: // s
							this._keys.backward = false;
							break;
						case 68: // d
							this._keys.right = false;
							break;
						case 32: // SPACE
							this._keys.space = false;
							break;
						case 16: // SHIFT
							this._keys.shift = false;
							break;
					}
				}
			};


			class FiniteStateMachine {
				constructor() {
					this._states = {};
					this._currentState = null;
				}

				_AddState(name, type) {
					this._states[name] = type;
				}

				SetState(name) {
					const prevState = this._currentState;

					if (prevState) {
						if (prevState.Name == name) {
							return;
						}
						prevState.Exit();
					}

					const state = new this._states[name](this);

					this._currentState = state;
					state.Enter(prevState);
				}

				Update(timeElapsed, input) {
					if (this._currentState) {
						this._currentState.Update(timeElapsed, input);
					}
				}
			};


			class CharacterFSM extends FiniteStateMachine {
				constructor(proxy) {
					super();
					this._proxy = proxy;
					this._Init();
				}

				_Init() {
					this._AddState('idle', IdleState);
					this._AddState('walk', WalkState);
					this._AddState('run', RunState);
					this._AddState('dance', DanceState);
				}
			};


			class State {
				constructor(parent) {
					this._parent = parent;
				}

				Enter() { }
				Exit() { }
				Update() { }
			};


			class DanceState extends State {
				constructor(parent) {
					super(parent);

					this._FinishedCallback = () => {
						this._Finished();
					}
				}

				get Name() {
					return 'dance';
				}

				Enter(prevState) {
					const curAction = this._parent._proxy._animations['dance'].action;
					const mixer = curAction.getMixer();
					mixer.addEventListener('finished', this._FinishedCallback);

					if (prevState) {
						const prevAction = this._parent._proxy._animations[prevState.Name].action;

						curAction.reset();
						curAction.setLoop(THREE.LoopOnce, 1);
						curAction.clampWhenFinished = true;
						curAction.crossFadeFrom(prevAction, 0.2, true);
						curAction.play();
					} else {
						curAction.play();
					}
				}

				_Finished() {
					this._Cleanup();
					this._parent.SetState('idle');
				}

				_Cleanup() {
					const action = this._parent._proxy._animations['dance'].action;

					action.getMixer().removeEventListener('finished', this._CleanupCallback);
				}

				Exit() {
					this._Cleanup();
				}

				Update(_) {
				}
			};


			class WalkState extends State {
				constructor(parent) {
					super(parent);
				}

				get Name() {
					return 'walk';
				}

				Enter(prevState) {
					const curAction = this._parent._proxy._animations['walk'].action;
					if (prevState) {
						const prevAction = this._parent._proxy._animations[prevState.Name].action;

						curAction.enabled = true;

						if (prevState.Name == 'run') {
							const ratio = curAction.getClip().duration / prevAction.getClip().duration;
							curAction.time = prevAction.time * ratio;
						} else {
							curAction.time = 0.0;
							curAction.setEffectiveTimeScale(1.0);
							curAction.setEffectiveWeight(1.0);
						}

						curAction.crossFadeFrom(prevAction, 0.5, true);
						curAction.play();
					} else {
						curAction.play();
					}
				}

				Exit() {
				}

				Update(timeElapsed, input) {
					if (input._keys.forward || input._keys.backward) {
						if (input._keys.shift) {
							this._parent.SetState('run');
						}
						return;
					}

					this._parent.SetState('idle');
				}
			};


			class RunState extends State {
				constructor(parent) {
					super(parent);
				}

				get Name() {
					return 'run';
				}

				Enter(prevState) {
					const curAction = this._parent._proxy._animations['run'].action;
					if (prevState) {
						const prevAction = this._parent._proxy._animations[prevState.Name].action;

						curAction.enabled = true;

						if (prevState.Name == 'walk') {
							const ratio = curAction.getClip().duration / prevAction.getClip().duration;
							curAction.time = prevAction.time * ratio;
						} else {
							curAction.time = 0.0;
							curAction.setEffectiveTimeScale(1.0);
							curAction.setEffectiveWeight(1.0);
						}

						curAction.crossFadeFrom(prevAction, 0.5, true);
						curAction.play();
					} else {
						curAction.play();
					}
				}

				Exit() {
				}

				Update(timeElapsed, input) {
					if (input._keys.forward || input._keys.backward) {
						if (!input._keys.shift) {
							this._parent.SetState('walk');
						}
						return;
					}

					this._parent.SetState('idle');
				}
			};


			class IdleState extends State {
				constructor(parent) {
					super(parent);
				}

				get Name() {
					return 'idle';
				}

				Enter(prevState) {
					const idleAction = this._parent._proxy._animations['idle'].action;
					if (prevState) {
						const prevAction = this._parent._proxy._animations[prevState.Name].action;
						idleAction.time = 0.0;
						idleAction.enabled = true;
						idleAction.setEffectiveTimeScale(1.0);
						idleAction.setEffectiveWeight(1.0);
						idleAction.crossFadeFrom(prevAction, 0.5, true);
						idleAction.play();
					} else {
						idleAction.play();
					}
				}

				Exit() {
				}

				Update(_, input) {
					if (input._keys.forward || input._keys.backward) {
						this._parent.SetState('walk');
					} else if (input._keys.space) {
						this._parent.SetState('dance');
					}
				}
			};


			class ThirdPersonCamera {
				constructor(params) {
					this._params = params;
					this._camera = params.camera;

					this._currentPosition = new THREE.Vector3();
					this._currentLookat = new THREE.Vector3();
				}

				_CalculateIdealOffset() {
					const idealOffset = new THREE.Vector3(-15, 20, -30);
					idealOffset.applyQuaternion(this._params.target.Rotation);
					idealOffset.add(this._params.target.Position);
					return idealOffset;
				}

				_CalculateIdealLookat() {
					const idealLookat = new THREE.Vector3(0, 10, 50);
					idealLookat.applyQuaternion(this._params.target.Rotation);
					idealLookat.add(this._params.target.Position);
					return idealLookat;
				}

				Update(timeElapsed) {
					const idealOffset = this._CalculateIdealOffset();
					const idealLookat = this._CalculateIdealLookat();

					// const t = 0.05;
					// const t = 4.0 * timeElapsed;
					const t = 1.0 - Math.pow(0.001, timeElapsed);

					this._currentPosition.lerp(idealOffset, t);
					this._currentLookat.lerp(idealLookat, t);

					this._camera.position.copy(this._currentPosition);
					this._camera.lookAt(this._currentLookat);
				}
			}


			class ThirdPersonCameraDemo {
				constructor() {
					this._Initialize();
				}

				_Initialize() {
					// this._threejs = new THREE.WebGLRenderer({
					// 	antialias: true,
					// });
					// this._threejs.outputEncoding = THREE.sRGBEncoding;
					// this._threejs.shadowMap.enabled = true;
					// this._threejs.shadowMap.type = THREE.PCFSoftShadowMap;
					// this._threejs.setPixelRatio(window.devicePixelRatio);
					// this._threejs.setSize(window.innerWidth, window.innerHeight);

					// document.body.appendChild(this._threejs.domElement);

					// window.addEventListener('resize', () => {
					// 	this._OnWindowResize();
					// }, false);

					// const fov = 60;
					// const aspect = 1920 / 1080;
					// const near = 1.0;
					// const far = 1000.0;
					// this._camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
					// this._camera.position.set(25, 10, 25);

					// this.scene = new THREE.Scene();


					// let light = new THREE.DirectionalLight(0xFFFFFF, 1.0);
					// light.position.set(-100, 100, 100);
					// light.target.position.set(0, 0, 0);
					// light.castShadow = true;
					// light.shadow.bias = -0.001;
					// light.shadow.mapSize.width = 4096;
					// light.shadow.mapSize.height = 4096;
					// light.shadow.camera.near = 0.1;
					// light.shadow.camera.far = 500.0;
					// light.shadow.camera.near = 0.5;
					// light.shadow.camera.far = 500.0;
					// light.shadow.camera.left = 50;
					// light.shadow.camera.right = -50;
					// light.shadow.camera.top = 50;
					// light.shadow.camera.bottom = -50;
					// this.scene.add(light);

					// light = new THREE.AmbientLight(0xFFFFFF, 0.25);
					// this.scene.add(light);

					// const loader = new THREE.CubeTextureLoader();
					// const texture = loader.load([
					// 	'./resources/posx.jpg',
					// 	'./resources/negx.jpg',
					// 	'./resources/posy.jpg',
					// 	'./resources/negy.jpg',
					// 	'./resources/posz.jpg',
					// 	'./resources/negz.jpg',
					// ]);
					// texture.encoding = THREE.sRGBEncoding;
					// this.scene.background = texture;

					// const plane = new THREE.Mesh(
					// 	new THREE.PlaneGeometry(100, 100, 10, 10),
					// 	new THREE.MeshStandardMaterial({
					// 		color: 0x808080,
					// 	}));
					// plane.castShadow = false;
					// plane.receiveShadow = true;
					// plane.rotation.x = -Math.PI / 2;
					// this.scene.add(plane);
					const loader = new FBXLoader();//permet le bon fonctionnemennt du model (type du model 3D)
					loader.setPath('resources/ac/');
					loader.load('mremireh_o_desbiens.fbx', (fbx) => {
						fbx.scale.setScalar(0.9);
						fbx.traverse(c => {
							c.castShadow = true;
						});

						const params = {
							target: fbx,
							camera: this._camera,
						}
						this._controls = new BasicCharacterControls(params);

						scene.add(fbx);
						fbx.position.set(-50, 10, 500);
					});


					this._mixers = [];
					this._previousRAF = null;

					this._LoadAnimatedModel();
					this._RAF();


				}

				_LoadAnimatedModel() {
					const params = {
						camera: this._camera,
						scene: this.scene,
					}
					this._controls = new BasicCharacterController(params);

					this._thirdPersonCamera = new ThirdPersonCamera({
						camera: this._camera,
						target: this._controls,
					});
				}


				_OnWindowResize() {
					this._camera.aspect = window.innerWidth / window.innerHeight;
					this._camera.updateProjectionMatrix();
					this._threejs.setSize(window.innerWidth, window.innerHeight);
				}

				_RAF() {
					requestAnimationFrame((t) => {
						if (this._previousRAF === null) {
							this._previousRAF = t;
						}

						this._RAF();

						this._threejs.render(this.scene, this._camera);
						this._Step(t - this._previousRAF);
						this._previousRAF = t;
					});
				}

				_Step(timeElapsed) {
					const timeElapsedS = timeElapsed * 0.001;
					if (this._mixers) {
						this._mixers.map(m => m.update(timeElapsedS));
					}

					if (this._controls) {
						this._controls.Update(timeElapsedS);
					}

					this._thirdPersonCamera.Update(timeElapsedS);
				}
			}


			let _APP = null;

			window.addEventListener('DOMContentLoaded', () => {
				_APP = new ThirdPersonCameraDemo();
			});




		</script>

	</body>

</html>